{"name":"Hxtracer","tagline":"A dependency-free Javascript Tracer","body":"## Introduction\r\n---\r\n\r\nI wrote this javascript tracer to gain a better insight into how a project worked. Hopefully it'll help others too. Keep reading for an explanation on how it works.\r\n\r\n## How do I use it?\r\n---\r\n\r\nSimply require this module somewhere:\r\n```\r\nvar hxTracer = require('hxtracer');\r\n```\r\nOr, include it on a webpage.\r\n\r\nThe tracer starts off disabled, when you get near a code path you want to trace:\r\n```\r\nhxTracer.start();\r\n```\r\nthen when finished:\r\n```\r\nhxTracer.stop();\r\n```\r\neg:\r\n```\r\nhxTracer.start();\r\ncache.storeObject('test', { key: 'foobar' }, function(err) {\r\n\thxTracer.stop();\r\n});\r\n```\r\nOr, the tracer can be toggled on/off by sending the process a PIPE signal:\r\n```\r\n/repos/redis-benchmark:ps aux | grep node\r\nusername    14116 15.5  0.1 662156 21992 pts/0    Sl+  22:27   0:00 node test.js\r\n/repos/redis-benchmark:kill -PIPE 14116\r\n```\r\n\r\nWhen your project runs into the tracer it will spit tracing info out to `stderr` like this:\r\n```\r\nTRACER OVERHEAD 0.13ms per timing\r\n...\r\nTRACER FNI 4398.08ms 6440456  /repos/redis-benchmark/Cache.js.prototype.findObject\r\nTRACER FNI 4398.14ms 6440456    /repos/redis-benchmark/Cache.js.prototype.generateCacheKey\r\nTRACER FNR 4398.19ms 6440456    /repos/redis-benchmark/Cache.js.prototype.generateCacheKey\r\nTRACER FNI 4398.25ms 6440456    /repos/redis-benchmark/Cache.js.prototype.get\r\nTRACER FNR 4398.29ms 6440456    /repos/redis-benchmark/Cache.js.prototype.get\r\nTRACER FNR 4398.33ms 6440456  /repos/redis-benchmark/Cache.js.prototype.findObject\r\n...\r\nTRACER EV LAG 59ms\r\n...\r\nTRACER FNI 4403.47ms 6440456  /repos/redis-benchmark/Cache.js.prototype._processGetQueue\r\nTRACER FNI 4404.02ms 6440456    /repos/redis-benchmark/Cache.js.prototype.mget\r\nTRACER FNI 4404.12ms 6440456      /repos/redis-benchmark/RedisClient.js.prototype.mget\r\nTRACER FNI 4404.28ms 6440456        /repos/redis-benchmark/RedisClient.js.prototype._isClientConnected\r\nTRACER FNR 4404.35ms 6440456        /repos/redis-benchmark/RedisClient.js.prototype._isClientConnected\r\nTRACER FNR 4404.60ms 6440456      /repos/redis-benchmark/RedisClient.js.prototype.mget\r\nTRACER FNR 4404.64ms 6440456    /repos/redis-benchmark/Cache.js.prototype.mget\r\nTRACER FNR 4404.70ms 6440456  /repos/redis-benchmark/Cache.js.prototype._processGetQueue\r\n...\r\n[Test finished in 203ms]\r\nTRACER CBR 4775.91ms 6440456  /repos/redis-benchmark/node_modules/async/lib/async.js.parallel\r\nTRACER CBR 4776.05ms 6442576    /repos/redis-benchmark/node_modules/async/lib/async.js.map\r\nTRACER CBR 4776.16ms 6444720      /repos/redis-benchmark/node_modules/async/lib/async.js.each\r\nTRACER CBR 4776.26ms 6446872        /repos/redis-benchmark/Cache.js.prototype.findObject\r\nTRACER CBR 4776.36ms 6449016          /repos/redis-benchmark/Cache.js.prototype.get\r\nTRACER EV LAG 71ms\r\nTRACER TOTAL OVERHEAD 7.27ms\r\nTRACER TOTAL 202.02ms 202.33ms 202.02ms 1 /repos/redis-benchmark/node_modules/async/lib/async.js.parallel\r\nTRACER TOTAL 200.73ms 201.29ms 200.73ms 1 /repos/redis-benchmark/node_modules/async/lib/async.js.map\r\nTRACER TOTAL 199.87ms 200.74ms 199.87ms 1 /repos/redis-benchmark/node_modules/async/lib/async.js.each\r\nTRACER TOTAL 31.30ms 106.57ms 183.26ms 100 /repos/redis-benchmark/Cache.js.prototype.findObject\r\nTRACER TOTAL 30.69ms 106.31ms 182.95ms 100 /repos/redis-benchmark/Cache.js.prototype.get\r\nTRACER TOTAL 3.53ms 3.68ms 3.53ms 1 /repos/redis-benchmark/Cache.js.prototype.mget\r\nTRACER TOTAL 3.20ms 3.51ms 3.20ms 1 /repos/redis-benchmark/RedisClient.js.prototype.mget\r\nTRACER TOTAL 2.56ms 2.56ms 2.56ms 1 /repos/redis-benchmark/Cache.js.prototype._processGetQueue\r\nTRACER TOTAL 0.04ms 0.37ms 27.89ms 100 /repos/redis-benchmark/Cache.js.prototype.generateCacheKey\r\nTRACER TOTAL 0.20ms 0.20ms 0.20ms 1 /repos/redis-benchmark/RedisClient.js.prototype._isClientConnected\r\n```\r\n\r\nWhere:\r\n`FNI` is `Function Invoked`, `FNR` is `Function Returned`, `CBI` is `Callback Invoked`, `CBR` is `Callback Returned`.\r\nThe columns provided by `TRACER TOTAL` are: `min duration`, `average duration`, `max duration`, `call count`, `file`.\r\n\r\nIf you want the tracer to stop at extra places, you can:\r\n```\r\nhxTracer.log('Cache Callback');\r\n```\r\n\r\n\r\n## Tracing a Node.js project\r\n---\r\n\r\n### Setting the Scene\r\n\r\nHere's some code I'd like to trace, annotated with a few points which are, or might be, interesting.\r\n```\r\nvar async = require('async');\r\nvar library = require('lib/library');\r\n\r\n// Point A\r\nasync.map(listOfCodes, function(code, callback) {\r\n  // Point B\r\n  library.findObjectsByCode(code, function(err, results) {\r\n    // Point C\r\n    if (err) return callback(null, [ ]);\r\n    return callback(null, results); // Point D\r\n  });\r\n  return; // Point E\r\n}, function(err, results) {\r\n  // Point F\r\n  results = results || [ ];\r\n  console.log(Array.prototype.concat.apply([ ], results);\r\n  return; // Point G\r\n});\r\nreturn; // Point H\r\n```\r\nWhen tracing this, I would like to know what code paths are being followed, the order in which they are being executed, how long it is taking to get between the various code points annotated above, and how much time in total is being spent in various functions.\r\n\r\n### Examining the 'module' module.\r\nThis is a trimmed down version of the structure of a `module` object:\r\n```\r\n> console.log(module);\r\n{ exports: { ... },\r\n  parent: { ..reference to the module that referenced this module.. },\r\n  children: [ { ..reference to modules required by this one.. } ] }\r\n```\r\nThe exports property contains a reference to the cached `module.exports` for the given module.\r\n\r\nApart from the starting module, whose `parent` will be `undefined`, the `parent` and `children` properties form circular references:\r\n```\r\n> [ some module ].parent.children.indexOf([ some module ]) >= 0\r\ntrue\r\n> console.log(JSON.stringify(module, null, 2))\r\nTypeError: Converting circular structure to JSON\r\n```\r\nThis is both awesome and terrible at the same time - it means that any included module in a given project can obtain the references to every loaded module in the entire project. It also means that any module can alter the exports or behaviour of any other module in the project:\r\n```\r\nvar async = require('async);\r\nmodule.parent.children[0].exports.foo = 'bar';\r\nconsole.log(async.foo);\r\n```\r\nSo how can we abuse this power to trace an entire project?\r\n\r\n### Scoping out a project\r\nFirst we need to start by locating the core module that spawned the whole project. From anywhere, grab the 'global' (well, within scope of each file) `module` object and traverse to the top of the tree:\r\n```\r\nvar parentModule = module;\r\nwhile (parentModule.parent) parentModule = parentModule.parent;\r\n```\r\nThen we've just got to work our way back down the tree obtaining references to every modules exports. In this example, every module's exports get run through a `bootstrap` function:\r\n```\r\nfunction processModules(item) {\r\n  if (item.exports && !item._traced) {\r\n    bootstrap(item, 'exports', item.filename);\r\n    item._traced = true;\r\n  }\r\n  if (item.children) {\r\n    item.children.map(processModules);\r\n  }\r\n}\r\nprocessModules(parentModule);\r\n```\r\nAs it stands, this will bootstrap every function in every module - tracing our 3rd party modules at a high level can be great, digging deeper into them is just going to create a lot of noise and make it harder to focus on our own code. We can limit the coverage to something a bit more sensible:\r\n```\r\nif ( ((path.indexOf('node_modules') !== -1) && (path.split('node_modules')[1].split('/').length > 3)) ||\r\n     (path.split('.').length > 5) ) return;\r\n```\r\n\r\n### Infecting enough code for a basic trace\r\nSo first up is attacking the exported objects - the most common exports patterns that I'm interested in are these two:\r\n```\r\nfunction SomeClass();\r\nmodule.exports = SomeClass;\r\nSomeClass.prototype.foo = function() { .... };\r\n```\r\nand\r\n```\r\nmodule.exports = {\r\n  foo = function() { .... }\r\n};\r\n```\r\nSo we've simply going to traverse every modules exports - if the value is a `Function` then we're going to go after both it, it's prototype and any static properties attached to it. We're then going to iterate over every property on the value, looking for other `Function` references or objects and repeat the process:\r\n```\r\nfunction bootstrap(item, path) {\r\n  var original = item[prop];\r\n  if (item[prop] instanceof Function) {\r\n    // Infect the actual function\r\n    infect(item, prop, path);\r\n    // Infect the functions prototype\r\n    if (item[prop].prototype) {\r\n      bootstrap(item[prop], 'prototype', path+'.prototype');\r\n    }\r\n    // Clone the static properties on the original function\r\n    for (var i in original) {\r\n      item[prop][i] = original[i];\r\n    }\r\n  }\r\n  if (item[prop] instanceof Object) {\r\n    // Bootstrap any other properties\r\n    for (var i in item[prop]) {\r\n      bootstrap(item[prop], i, path+'.'+i);\r\n    }\r\n  }\r\n  return item;\r\n}\r\n```\r\nNow we want to alter every one of these functions so that we can work out what order events are occuring, and how long it is taking to get between different code points. All we've got to do is record the original function reference then replace it with one of our own which does some tracing and calls on to the original. This is the basic format I've gone with:\r\n```\r\nfunction infect(item, i, path) {\r\n  var original = item[i];\r\n  item[i] = function() {\r\n    return (function() {\r\n      // ... trace stuff\r\n      // ... invoke the original function, passing the correct scope\r\n      // ... trace some more\r\n      // ... return the result\r\n    }).apply(this, Array.prototype.slice.call(arguments));\r\n  };\r\n\r\n  // Make sure we don't lose any prototypes!\r\n  item[i].prototype = original.prototype;\r\n}\r\n```\r\nThis is cool, we're now tracing a bunch of functions across our project, but it's not covering some of the more interesting parts like anonymous functions or functions that are passed around to other modules.\r\n\r\n### Tracing the anonymous functions\r\nThe trick here is not to think too hard about how to get these in scope. Most of the anonymous functions we're going to be interested in are passed into the functions we've already traced, so tweaking them is remarkably simple. This example is an extension of the previous one:\r\n```\r\nfunction infect(item, i, path) {\r\n  var original = item[i];\r\n  item[i] = function() {\r\n    return (function() {\r\n      var functionArgs = Array.prototype.slice.call(arguments);\r\n      functionArgs = functionArgs.map(function(arg) {\r\n        if (!(arg instanceof Function)) return arg;\r\n        return function() {\r\n          // ... trace stuff\r\n          // ... invoke the original function, passing the correct scope\r\n          // ... trace some more\r\n          // ... return the result\r\n        };\r\n      });\r\n\r\n      // ... trace stuff\r\n      // ... invoke the original function, passing the correct scope\r\n      // ... trace some more\r\n      // ... return the result\r\n    }).apply(this, Array.prototype.slice.call(arguments));\r\n  };\r\n\r\n  // Make sure we don't lose any prototypes!\r\n  item[i].prototype = original.prototype;\r\n}\r\n```\r\nThe idea is simple - whenever a traced function is invoked, if it's passed a function then we change it for a new one which does our tracing and continues on to where it was meant to go. Wonderful.\r\n\r\n### Allowing Dependency Injection\r\nSome modules like to stringify functions to see how many parameters have been named, then altering how those functions are invoked accordingly. If we want this to continue working with our tracer we need to go a bit further and tweak our new functions parameters to match those of the original:\r\n```\r\nvar dependencies = original.toString().match(/^function .*?\\((.*?)\\)/);\r\nif (dependencies) {\r\n  var newFunc = item[i].toString();\r\n  newFunc = '(function() { return '+newFunc.replace('function ()', 'function ('+dependencies[1]+')')+ '; })()';\r\n  item[i] = eval(newFunc);\r\n}\r\n```\r\nThis part is less than pleasant, but it gets the job done.\r\n\r\n### Measuring Time\r\nWe are going to need sub-millisecond accuracy when measuring how long it takes to get from A to B. Node provides this:\r\n```\r\n> process.hrtime();\r\n[ 99343, 41943674 ]\r\n```\r\nThose two numbers are `seconds` then `nanoseconds` and are described in the documentation as `It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals.`. We're going to combine these numbers, move the decimal place to milliseconds, round off the nanoseconds and reduce the number down to something easier to read: `1234.56ms`\r\n```\r\nfunction meaningfulTime() {\r\n  var parts = process.hrtime();\r\n  return (((parts[0]*1000)+(parts[1]/1000000))%10000).toFixed(2) + 'ms';\r\n}\r\n```\r\n","google":"UA-46962272-1","note":"Don't delete this file! It's used internally to help with page regeneration."}